import os
import subprocess
from pathlib import Path


def generate_grid_network(
    seed: int,
    dimension: int,
    block_size_m: int,
    output_file: str,
    blocks_to_remove: int = 0
):
    """
    Generate an orthogonal grid network with static traffic lights.

    This uses a two-step process:
    1. Create the base grid with netgenerate.
    2. Inject static traffic lights with netconvert.

    :param seed: Random seed (unused for deterministic grid generation)
    :param dimension: Number of rows/columns of junctions (e.g., 5 for 5Ã—5)
    :param block_size_m: Length of each block in meters
    :param output_file: Path to write the final .net.xml file
    :param blocks_to_remove: Number of blocks to remove (not supported)
    """
    output_path = Path(output_file)
    base_net = output_path.with_name(f"{output_path.stem}_base.net.xml")

    # Step 1: Generate grid without traffic lights
    cmd_gen = [
        "netgenerate",
        "--grid",
        "--grid.number", str(dimension),
        "--grid.length", str(block_size_m),
        "--grid.attach-length", "0",
        "--output-file", str(base_net)
    ]
    try:
        subprocess.run(cmd_gen, check=True, capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        raise Exception(f"Error during netgenerate execution: {e.stderr}")

    # Step 2: Inject static traffic lights via netconvert
    cmd_tls = [
        "netconvert",
        "--sumo-net-file", str(base_net),
        "--tls.guess",
        "--tls.default-type", "static",
        "--output-file", str(output_path)
    ]
    # Run netconvert (may succeed without adding TL logic)
    subprocess.run(cmd_tls, check=True, capture_output=True, text=True)

    # Check if tlLogic tags are present, if not perform manual injection
    content = output_path.read_text(20000)
    if '<tlLogic' not in content:
        from xml.etree import ElementTree as ET
        # Parse the fresh output or base_net if output missing
        tree = ET.parse(str(output_path))
        root = tree.getroot()
        # Inject tlLogic for each non-internal junction
        for j in root.findall('junction'):
            jid = j.get('id')
            if jid.startswith(':'):
                continue
            tl = ET.Element('tlLogic', id=jid, type='static',
                            programID='0', offset='0')
            # Default two-phase: all green for NS then EW
            ET.SubElement(tl, 'phase', duration='30', state='GGrr')
            ET.SubElement(tl, 'phase', duration='30', state='rrGG')
            # Insert tlLogic into root
            root.append(tl)
        # Write back injected file
        tree.write(str(output_path))

    # Clean up intermediate base network
    if base_net.exists():
        base_net.unlink()

    # Block removal not implemented
    if blocks_to_remove != 0:
        raise NotImplementedError("Block removal not supported yet")

    # Verify output exists and contains traffic light logic
    if not output_path.exists():
        raise Exception(
            f"Error: Network file '{output_path}' was not created.")
    # Read a portion of file to check for <tlLogic>
    with output_path.open('r', encoding='utf-8') as f:
        content = f.read(20000)
    if '<tlLogic' not in content:
        raise Exception(
            "Error: Generated network missing <tlLogic> definitions.")
