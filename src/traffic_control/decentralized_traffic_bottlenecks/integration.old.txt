"""
integration.py – tiny wrapper that prepares the Tree-method controller
and lets the upstream runner launch SUMO-GUI.

It does three things:
1. Makes sure the expected config file name (simulation.sumocfg) exists.
2. Builds a RunConfig instance with the enum values that exist in *your*
   copy of enums.py.
3. Delegates everything to runner.run(), which starts sumo-gui and drives
   the traffic lights via TraCI.
"""
from pathlib import Path
import sys
import shutil
from .classes.net_data_builder import NetworkData

# ---------------------------------------------------------------------------
# Make the package itself importable as top-level “classes.*”
# (runner.py expects:  from classes.graph import Graph)
# ---------------------------------------------------------------------------
pkg_dir = Path(__file__).resolve().parent
if str(pkg_dir) not in sys.path:
    sys.path.insert(0, str(pkg_dir))

# ---------------------------------------------------------------------------
# Upstream objects
# ---------------------------------------------------------------------------
from .runner               import run as tree_run          # upstream entry-point
from .classes.run_config    import RunConfig               # data-class
from .enums                 import CostType, AlgoType      # enum definitions

# ---------------------------------------------------------------------------
# Public API – called once from src/cli.py
# ---------------------------------------------------------------------------
def run_tree_method(
    net_file: str,
    route_file: str,                # kept for symmetry – not used by runner.py
    sumo_cfg: str,
    *,
    sumo_binary: str = "sumo-gui",
) -> None:
    """
    Launch SUMO-GUI with the Tree-method controller.

    Parameters
    ----------
    net_file   : full path to grid.net.xml you just generated
    route_file : vehicles.rou.xml (ignored, runner finds it itself)
    sumo_cfg   : path returned by generate_sumo_conf_file(...)  (grid.sumocfg)
    sumo_binary: "sumo-gui" (default) or "sumo" for headless
    """

    # -----------------------------------------------------------------------
    # 1. The upstream runner is hard-coded to look for
    #       <work_dir>/simulation.sumocfg
    #    so copy/rename grid.sumocfg -> simulation.sumocfg if needed.
    # -----------------------------------------------------------------------
    work_dir   = Path(sumo_cfg).parent          # e.g.  data/
    target_cfg = work_dir / "simulation.sumocfg"
    if not target_cfg.exists():
        shutil.copyfile(sumo_cfg, target_cfg)   # grid.sumocfg -> simulation.sumocfg


    # ── build the JSON topology file expected by Network(…) ─────────────
    json_topology = Path(net_file).with_suffix(".json")
    if not json_topology.exists():
        NetworkData(net_file, str(json_topology))        # writes <grid>.json

    # -----------------------------------------------------------------------
    # 2. Build a RunConfig – only *required* fields, using enum names that
    #    actually exist in your enums.py.
    # -----------------------------------------------------------------------
    rc = RunConfig(
        is_actuated=False,
        output_directory=str(work_dir),
        cost_type=CostType.TREE_CURRENT,   # <-- present in your CostType enum
        algo_type=AlgoType.PLANNED,        # <-- present in your AlgoType enum
    )

    # -----------------------------------------------------------------------
    # 3. Delegate to the upstream runner.  It starts sumo-gui, opens TraCI,
    #    and drives every traffic light until the simulation ends.
    # -----------------------------------------------------------------------
    tree_run(
        sumo_binary,             # "sumo-gui"
        str(work_dir),           # path          (folder that holds simulation.sumocfg)
        str(work_dir),           # output_path   (same folder is fine)
        net_file,                # input_network_file
        rc,                      # configuration dataclass
    )
