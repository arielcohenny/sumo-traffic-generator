import os
import argparse
import random
import shutil
from alive_progress import *

import traci
from src.sim.sumo_controller import SumoController
from src.sim.sumo_utils import generate_sumo_conf_file

from src.network.generator import *
from src.network.lanes import set_lane_counts
from src.network.edge_attrs import assign_edge_attractiveness
from src.network.zones import extract_zones_from_junctions
from src.traffic.builder import generate_vehicle_routes
from src.config import CONFIG

from src.traffic_control.decentralized_traffic_bottlenecks.integration import load_tree, compute_phases


def main():
    # --- Global Variables and Constants ---
    if os.path.exists(CONFIG.output_dir):
        shutil.rmtree(CONFIG.output_dir)
    os.makedirs(CONFIG.output_dir, exist_ok=True)

    # --- Command-line Argument Parsing ---
    parser = argparse.ArgumentParser(
        description="Generate and simulate a SUMO orthogonal grid network with dynamic traffic-light control."
    )
    parser.add_argument(
        "--grid_dimension",
        type=float,
        default=5,
        help="The grid's number of rows and columns. Default is 5 (5x5 grid)."
    )
    parser.add_argument(
        "--block_size_m",
        type=int,
        default=200,
        help="Block size in meters. Default is 200m."
    )
    parser.add_argument(
        "--blocks_to_remove",
        type=int,
        default=0,
        help="Number of blocks to remove from the grid. Default is 0."
    )
    parser.add_argument(
        "--num_vehicles",
        type=int,
        default=CONFIG.DEFAULT_NUM_VEHICLES,
        help=f"Number of vehicles to generate. Default is {CONFIG.DEFAULT_NUM_VEHICLES}."
    )
    parser.add_argument(
        "--seed",
        type=int,
        help="Seed for generating randomness. If not provided, a random seed will be used."
    )
    parser.add_argument(
        "--step-length",
        type=float,
        default=1.0,
        help="Simulation step length in seconds (for TraCI loop)."
    )
    parser.add_argument(
        "--end-time",
        type=int,
        default=3600,
        help="Total simulation duration in seconds."
    )
    parser.add_argument(
        "--gui",
        action="store_true",
        help="Launch SUMO in GUI mode (sumo-gui) instead of headless sumo"
    )
    args = parser.parse_args()

    try:
        print("Begin simulating SUMO orthogonal grid network...")

        # --- Initialize seed ---
        seed = args.seed if args.seed is not None else random.randint(
            0, 2**32 - 1)
        print(f"Using seed: {seed}")

        # --- Step 1: Generate the Orthogonal Grid Network ---
        generate_grid_network(
            seed,
            int(args.grid_dimension),
            int(args.block_size_m),
            CONFIG.network_file,
            int(args.blocks_to_remove)
        )
        print(f"Generated network file: {CONFIG.network_file}")

        # --- Step 2: Extract Zones - --
        extract_zones_from_junctions(
            CONFIG.network_file,
            args.block_size_m,
            CONFIG.output_dir,
            seed=seed,
            fill_polygons=True,
            inset=0.0
        )
        print("Extracted zones")

        # --- Step 3: Set Lane Counts ---
        set_lane_counts(
            net_file_in=CONFIG.network_file,
            net_file_out=CONFIG.network_file,
            seed=seed
        )
        print("Set lane counts for edges")

        # --- Step 4: Assign Edge Attractiveness ---
        assign_edge_attractiveness(
            seed,
            CONFIG.network_file,
            lambda_depart=3.5,
            lambda_arrive=2.0
        )
        print("Assigned edge attractiveness")

        # --- Step 5: Inject Static Traffic Lights ---
        inject_traffic_lights(CONFIG.network_file)
        print("Injected static traffic lights into network")

        # --- Step 6: Generate Vehicle Routes ---
        generate_vehicle_routes(
            net_file=CONFIG.network_file,
            output_file=CONFIG.routes_file,
            num_vehicles=args.num_vehicles,
            seed=seed
        )
        print("Generated vehicle routes.")

        # --- Step 7: Generate SUMO Configuration File ---
        sumo_cfg_path = generate_sumo_conf_file(
            CONFIG.config_file,
            CONFIG.network_file,
            route_file=CONFIG.routes_file
        )
        print(f"Generated SUMO configuration file: {sumo_cfg_path}")

        # --- Step 8: Dynamic Simulation via TraCI & Tree Method ---
        # Load network tree structure and runner configuration
        json_file = Path(CONFIG.network_file).with_suffix(".json")
        if json_file.exists():
            json_file.unlink()
        tree_data, run_config = load_tree(
            net_file=CONFIG.network_file,
            sumo_cfg=sumo_cfg_path
        )
        print("Loaded network tree and run configuration.")

        # Initialize the TraCI controller
        # controller = SumoController(
        #     sumo_cfg=sumo_cfg_path,
        #     step_length=args.step_length,
        #     end_time=args.end_time
        # )
        controller = SumoController(
            sumo_cfg=sumo_cfg_path,
            step_length=args.step_length,
            end_time=args.end_time,
            gui=args.gui
        )
        print("Initialized TraCI controller.")

        # Define per-step control callback

        # ------------------------------------------------------------------
        # QUICK “even/odd” sanity-check controller
        # ------------------------------------------------------------------
        GREEN = 30      # s
        YELLOW = 3       # s
        CYCLE = GREEN + YELLOW     # 33 s
        FULL = 2 * CYCLE          # 66 s  (NS part + EW part)

        def _build_states(tls_id: str):
            """
            Return four strings (ns_G, ns_Y, ew_G, ew_Y) whose length matches
            len(traci.trafficlight.getControlledLinks(tls_id)).
            Even linkIndex ⇒ treat as NS; odd ⇒ EW.
            """
            n = len(traci.trafficlight.getControlledLinks(tls_id))
            mask = [(i % 2 == 0) for i in range(n)]          # True → NS
            def _fmt(on, off): return ''.join(on if m else off for m in mask)
            return (
                _fmt('G', 'r'),  # ns green
                _fmt('y', 'r'),  # ns yellow
                _fmt('r', 'G'),  # ew green
                _fmt('r', 'y')   # ew yellow
            )

        def control_callback(current_time: int):
            """
            Two-phase plan just to prove the phase-size error disappears when
            each TLS gets a correct-length string.
            """
            t = int(current_time) % FULL
            use_ns = t < CYCLE          # first half-cycle = NS
            in_green = t % CYCLE < GREEN  # first 30 s of each half

            for tls_id in traci.trafficlight.getIDList():
                ns_g, ns_y, ew_g, ew_y = _build_states(tls_id)
                state = (ns_g if in_green else ns_y) if use_ns else (
                    ew_g if in_green else ew_y)
                traci.trafficlight.setRedYellowGreenState(tls_id, state)

        # def control_callback(current_time: int):
        #     phase_map = compute_phases(
        #         tree_data,
        #         sim_time=current_time,
        #         run_config=run_config
        #     )
        #     for tls_id, state in phase_map.items():
        #         traci.trafficlight.setRedYellowGreenState(tls_id, state)

        # Run the simulation
        controller.run(control_callback)
        print("Simulation completed successfully.")

    except Exception as e:
        print(f"An error occurred. Error: {e}")
        exit(1)


if __name__ == "__main__":
    main()
